#include <stdio.h>
#include <Windows.h>
#include <curl/curl.h>
#include <string.h>
#include <cjson/cJSON.h>

#include "miscellaneous.h"
#include "ansi_colours.h"
#include "malshare.h"
#include "malpedia.h"
#include "unpac_me.h"
#include "config.h"
#include "malwarebazaar.h"

//Debug library
#include <crtdbg.h>

char* download_malware_query(char* api_key, char* sample_hash){
    char* answer = NULL;
    return answer;
}

// Not yet added.
BOOL download_malware_hybridanalysis(char* api_key, char* sample_hash){
    return FALSE;
}

// Ah, perfection. (✿◡‿◡)
BOOL download_malwarebazaar(char* sample_hash){
    if (malwarebazaar_download_file(sample_hash) != TRUE){
        return FALSE;
    } else {
        return TRUE;
    }
}

// Dumpster fire of a function, but it get's the job done.
BOOL download_malware_unpac_me(char* api_key, char* sample_hash){
    char* id_to_batch_job = unpac_me_get_batch_id(api_key, sample_hash);
    if (!id_to_batch_job){
        return FALSE;
    }

    cJSON* id_json = cJSON_Parse(id_to_batch_job);
    cJSON* token = cJSON_GetArrayItem(id_json, 0);

    HANDLE hThread_loading;
    DWORD dwThreadId;
    ApiCallLoading unpac_me_loading = { TRUE, "Waiting for batch job..." };

    hThread_loading = CreateThread(NULL, 0, LoadingAnimationSingleThread, &unpac_me_loading, 0, &dwThreadId);
    if (!hThread_loading){
        fprintf(stderr, ANSI_RED"[!] Error: Failed to create loading animation thread\n" ANSI_RESET);
        return FALSE;
    }

    Sleep(60000); // Must be a better way to do this...
    unpac_me_loading.batch_job_wait = FALSE;
    WaitForSingleObject(hThread_loading, INFINITE);
    CloseHandle(hThread_loading);

    cJSON* url_batch_job = cJSON_Parse(unpac_me_get_url_batch_job(token->valuestring, api_key));
    cJSON* url_string = cJSON_GetArrayItem(url_batch_job, 1);

    printf("[+] Requested URL Download String: %s\n", url_string->valuestring);
    free(api_key);
    return TRUE;
}

// Malpedia download function 
BOOL download_malware_malpedia(char* api_key, char* sample_hash){
    cJSON* malpedia_json = cJSON_Parse(malpedia_download_malware(api_key, sample_hash));
    if (!malpedia_json){
        free(api_key);
        cJSON_Delete(malpedia_json);
        return FALSE;
    }
    cJSON* data = cJSON_GetArrayItem(malpedia_json, 0);
    DecodedBase64BinaryData decoded = decode_base64(data->valuestring);

    char file_name[256];
    snprintf(file_name, sizeof(file_name), "%s.zip", sample_hash);
    create_file_nsterminated(file_name, decoded.data, decoded.size);

    
    free(api_key);
    cJSON_Delete(malpedia_json);
    return TRUE;
}

// Malshare download function
BOOL download_malware_malshare(char* api_key, char* sample_hash){
    if (malshare_download_file(api_key, sample_hash) == FALSE){
        return FALSE;
    } else {
        return TRUE;
    }
};


// Implementations of the download_malware functions for each API
BOOL download_malware(char* api_name, char* sample_hash){
    
    // This function will download the malware sample from the API.
    // The function will return TRUE if the malware sample was downloaded successfully.
    // The function will return FALSE if the malware sample was not downloaded successfully.

    // Check if the parameters are valid
    if (!sample_hash || !api_name){
        fprintf(stderr, ANSI_RED"[!] Error: Missing parameters\n" ANSI_RESET);
        return FALSE;
    }

    if (check_for_existence_of_file(sample_hash) == 0) {
        LOG_SUCCESS("File already exists: %s", sample_hash);
        return FALSE;
    }


    // Download from Malware Bazaar
    if (strcmp(api_name, "-mb") == 0 || strcmp(api_name, "default") == 0) {
        if (download_malwarebazaar(sample_hash) == FALSE) {
            LOG_ERROR("File is not available on MalwareBazaar : %s", sample_hash);
        } else {
            printf(ANSI_GREEN"[+] Successfully downloaded sample from MalwareBazaar\n" ANSI_RESET);
            return TRUE;
        }
    }

    // Download from Malpedia
    if (strcmp(api_name, "-mp") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("malpedia");
        if (!api_key){
            return FALSE;
        }

        if (malpedia_validate_key_hash(api_key, sample_hash) == FALSE){
            fprintf(stderr, ANSI_RED"[!] File is not available on Malpedia : %s\n" ANSI_RESET, sample_hash);
            free(api_key);
            
        } else {
            if (download_malware_malpedia(api_key, sample_hash) == FALSE){
                fprintf(stderr, ANSI_RED"[!] Error: Failed to download malware sample from Malpedia\n" ANSI_RESET);
            } else if (download_malware_malpedia(api_key, sample_hash) == TRUE){
                printf(ANSI_GREEN"[+] Successfully downloaded malware sample from Malpedia\n" ANSI_RESET);
                return TRUE;
            }
        }      
    }

     // Download from Unpac.Me
    if (strcmp(api_name, "-um") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("unpacme");
        if (!api_key){
            free(api_key);
            return FALSE;
        }

        if (unpac_me_validate_hash(api_key, sample_hash) == FALSE ){
            LOG_ERROR("File is not available on Unpac.Me : %s", sample_hash);
            free(api_key);
        } else {
            if (download_malware_unpac_me(api_key, sample_hash) == FALSE){
                fprintf(stderr, ANSI_RED"[!] Failed to download sample from Unpac.Me\n" ANSI_RESET);
            } else {
                printf(ANSI_GREEN"[+] Successfully downloaded malware sample from Unpac.Me\n" ANSI_RESET);
                return TRUE;
                }
        }
    }

    // Download from Malshare
    if (strcmp(api_name, "-ms") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("malshare"); 
        if (!api_key){
            return FALSE;
        }

        if (malshare_validate_hash(api_key, sample_hash) == FALSE) {
            fprintf(stderr, ANSI_RED"[!] File is not available on Malshare : %s\n" ANSI_RESET, sample_hash);
        } else {
            if (download_malware_malshare(api_key, sample_hash) == FALSE){
                fprintf(stderr, ANSI_RED"[!] Failed to download sample from Malshare\n" ANSI_RESET);
            } else {
                printf(ANSI_GREEN"[+] Successfully downloaded malware sample from Malshare\n" ANSI_RESET);
                return TRUE;
            }
        }

    }

    /*
    if (strcmp(api_name, "-ha") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("hybridanalysis");
        BOOL hybridanalysis_response = download_malware_hybridanalysis(api_key, sample_hash);
        free(api_key);
        if (hybridanalysis_response == FALSE){
            fprintf(stderr, ANSI_RED"[!] Error: Failed to download malware sample from hybridanalysis\n" ANSI_RESET);
        } else if (hybridanalysis_response == TRUE){
            printf(ANSI_GREEN"[+] Successfully downloaded malware sample from hybridanalysis\n" ANSI_RESET);
            return TRUE;
        }   
    }
    */

    fprintf(stderr, ANSI_RED"[!] Error: No API name provided or isn't amongst available APIs used to download malware\n" ANSI_RESET);
    return FALSE;
}





