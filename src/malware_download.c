#include <stdio.h>
#include <Windows.h>
#include <curl/curl.h>
#include <string.h>
#include <cjson/cJSON.h>

#include "miscellaneous.h"
#include "ansi_colours.h"
#include "malshare.h"
#include "malpedia.h"
#include "unpac_me.h"
#include "config.h"

//Debug library
#include <crtdbg.h>

BOOL download_malware(char* api_name, char* sample_hash){
    
    // This function will download the malware sample from the API.
    // The function will return TRUE if the malware sample was downloaded successfully.
    // The function will return FALSE if the malware sample was not downloaded successfully.

    // Check if the parameters are valid
    if (!sample_hash || !api_name){
        fprintf(stderr, ANSI_RED"[!] Error: Missing parameters\n" ANSI_RESET);
        return FALSE;
    }
    if (check_api_name(api_name) == FALSE){
        char* api_name = "default";
    }
    if (hash_sample_validation(sample_hash) == FALSE){
        fprintf(stderr, ANSI_RED"[!] Error: Invalid hash. Correct lengths are 32 || 64.\n" ANSI_RESET);
        return FALSE;
    }

    // Download the malware sample
    if (strcmp(api_name, "-um") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("unpacme");
        BOOL unpac_me_response = download_malware_unpac_me(api_key, sample_hash);
        free(api_key);
        if (unpac_me_response == FALSE){
            fprintf(stderr, ANSI_RED"[!] Error: Failed to download malware sample from unpac_me\n" ANSI_RESET);
        } else if (unpac_me_response == TRUE){
            printf(ANSI_GREEN"[+] Successfully downloaded malware sample from unpac_me\n" ANSI_RESET);
            return TRUE;
        }
    }

    if (strcmp(api_name, "-mp") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("malpedia");
        if (malpedia_check_key_hash(api_key, sample_hash) == FALSE){
            free(api_key);
            return FALSE;
        };

        BOOL malpedia_response = download_malware_malpedia(api_key, sample_hash);
        free(api_key);

        if (malpedia_response == FALSE){
            fprintf(stderr, ANSI_RED"[!] Error: Failed to download malware sample from malpedia\n" ANSI_RESET);
        } else if (malpedia_response == TRUE){
            printf(ANSI_GREEN"[+] Successfully downloaded malware sample from malpedia\n" ANSI_RESET);
            return TRUE;
        }
    }

    if (strcmp(api_name, "-ms") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("malshare"); 
        BOOL malshare_response = download_malware_malshare(api_key, sample_hash);
        free(api_key);
        if (malshare_response == FALSE){
            fprintf(stderr, ANSI_RED"[!] Error: Failed to download malware sample from malshare\n" ANSI_RESET);
        } else if (malshare_response == TRUE){
            printf(ANSI_GREEN"[+] Successfully downloaded malware sample from malshare\n" ANSI_RESET);
            return TRUE;
        }
    }

    if (strcmp(api_name, "-ha") == 0 || strcmp(api_name, "default") == 0) {
        char* api_key = get_api_key_value("hybridanalysis");
        BOOL hybridanalysis_response = download_malware_hybridanalysis(api_key, sample_hash);
        free(api_key);
        if (hybridanalysis_response == FALSE){
            fprintf(stderr, ANSI_RED"[!] Error: Failed to download malware sample from hybridanalysis\n" ANSI_RESET);
        } else if (hybridanalysis_response == TRUE){
            printf(ANSI_GREEN"[+] Successfully downloaded malware sample from hybridanalysis\n" ANSI_RESET);
            return TRUE;
        }   
    }

    fprintf(stderr, ANSI_RED"[!] Error: No API name provided or isn't amongst available APIs used to download malware\n" ANSI_RESET);
    return FALSE;
}

char* download_malware_query(char* api_key, char* sample_hash){
    char* answer = NULL;
    return answer;
}

// Implementations of the download_malware functions for each API
BOOL download_malware_unpac_me(char* api_key, char* sample_hash){
    char* id_to_batch_job = unpac_me_get_batch_id(api_key, sample_hash);
    if (!id_to_batch_job){
        return FALSE;
    }

    cJSON* id_json = cJSON_Parse(id_to_batch_job);
    cJSON* token = cJSON_GetArrayItem(id_json, 0);

    HANDLE hThread_loading;
    DWORD dwThreadId;
    ApiCallLoading unpac_me_loading = { TRUE, "Waiting for batch job..." };

    hThread_loading = CreateThread(NULL, 0, LoadingAnimationSingleThread, &unpac_me_loading, 0, &dwThreadId);
    if (!hThread_loading){
        fprintf(stderr, ANSI_RED"[!] Error: Failed to create loading animation thread\n" ANSI_RESET);
        return FALSE;
    }

    Sleep(60000); // Must be a better way to do this...
    unpac_me_loading.batch_job_wait = FALSE;
    WaitForSingleObject(hThread_loading, INFINITE);
    CloseHandle(hThread_loading);

    cJSON* url_batch_job = cJSON_Parse(unpac_me_get_url_batch_job(token->valuestring, api_key));
    cJSON* url_string = cJSON_GetArrayItem(url_batch_job, 1);

    printf("[+] Requested URL Download String: %s\n", url_string->valuestring);
    return TRUE;
}

BOOL download_malware_malpedia(char* api_key, char* sample_hash){
    cJSON* malpedia_json = cJSON_Parse(malpedia_download_malware(api_key, sample_hash));
    cJSON* data = cJSON_GetArrayItem(malpedia_json, 0);
    DecodedBase64BinaryData decoded = decode_base64(data->valuestring);



    free(api_key);
    cJSON_Delete(malpedia_json);
    return FALSE;
}

BOOL download_malware_malshare(char* api_key, char* sample_hash){

    char* downloaded_file_data = malshare_download_file(api_key, sample_hash);
    if (downloaded_file_data == NULL){
        return FALSE;
    }
    
    char* file_name = malloc(strlen(sample_hash) + 19); 
    if (file_name == NULL) {
        fprintf(stderr, ANSI_RED"[!] Error: Memory allocation failed\n" ANSI_RESET);
        free(downloaded_file_data);
        return FALSE;
    }
    sprintf(file_name, "malware_samples\\%s.bin", sample_hash);
    
    if (!create_file_sterminated(file_name, downloaded_file_data)){
        fprintf(stderr, ANSI_RED"[!] Error: Failed to create file\n" ANSI_RESET);
        return FALSE;
    } else {
        return TRUE;
    }

    return FALSE;
}

BOOL download_malware_hybridanalysis(char* api_key, char* sample_hash){
    return FALSE;
}





